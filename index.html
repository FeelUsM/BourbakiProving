<!DOCTYPE HTML>
<!-- 
Bourbaki proving 
(c) FeelUs
-->
<html>

<head>
	<meta charset="utf-8">
	<script src="jquery-2.2.0.js"></script>
	<script src="parser.js"></script>
	<script src="propsManager.js"></script>
</head>
<body>
	<a href="https://github.com/feelusm/BourbakiProving/">это система проверки доказательств</a><br>
	доказательство теории продолжайте в коде<br>
	если в нем будет ошибка, произойдет исключение, которое можно увидеть в консоли браузера<br>
	пункты, начинающиеся с &lt...&gt - можно разворачивать<br>
	<button onclick="show_all()">развернуть все</button><button onclick="hide_all()">свернуть все</button>
	<ul id="list">
	</ul>
<script>
/*
Object.defineProperty(Array.prototype, 'last', {
	enumerable:false,
	get:function(){
		return this[this.length-1];
	}
})
*/

function Op(op,args){
	if(this instanceof Op);else return new Op(op,args);
	console.assert(['!','||'].indexOf(op)!=-1);
	this.which = op;
	this.args = args;
	return this;
}
function not(arg){
	if(typeof arg === 'string') arg = parse(arg)
	return new Op('!',[arg]);
}
function or(arg1,arg2){
	if(typeof arg1 === 'string') arg1 = parse(arg1)
	if(typeof arg2 === 'string') arg2 = parse(arg2)
	return new Op('||',[arg1,arg2]);
}
//implication
function imp(arg1,arg2){
	return or(not(arg1),arg2);
}

	copyProps(Parser,window);
	var read_prim_expr = (str,pos)=> read_any(str,pos,collect,[
		(str,pos)=>{
			var r = read_rgx(str,pos,/^[A-Z_]+/);
			if(!isGood(r)) return new FatalError(pos.x,'ожидался идентификатор');
			if(!(r[0] in links)) return new FatalError(pos.x,'не объявлена ссылка '+r[0]);
			return links[r[0]];
		},
		(str,pos)=>{
			var r = read_seq(str,pos,need(1),[txt('(').exec,expr.exec,txt(')').exec]);
			if(!isGood(r)) return addErrMessage(r,' - in "(expr)"');
			return r;
		}
	]);
	var read_expr_not = (str,pos)=> read_any(str,pos,collect,[
		read_prim_expr,
		(str,pos)=>{
			var r = read_seq(str,pos,need(1),[txt('!').exec,read_expr_not]);
			if(!isGood(r)) return addErrMessage(r,' - in "!expr"');
			return not(r);
		}
	])
	var read_expr_or = (str,pos)=> read_any(str,pos,collect,[
		(str,pos)=>{
			var r = read_seq(str,pos,need(0,2),[read_expr_not,txt('||').exec,read_expr_not]);
			if(!isGood(r)) return addErrMessage(r,' - in "expr||expr"');
			return or(r[0],r[1]);
		},
		read_expr_not
	])
	var read_expr_and = read_expr_or;//	заменен на настоящий ниже
	var read_expr_imp = (str,pos)=> read_any(str,pos,collect,[
		(str,pos)=>{
			var r = read_seq(str,pos,need(0,2),[read_expr_and,txt('=>').exec,read_expr_and]);
			if(!isGood(r)) return addErrMessage(r,' - in "expr=>expr"');
			return imp(r[0],r[1]);
		},
		read_expr_and
	])
	// добавляется eql
	var expr = new Pattern(read_expr_imp);
function parse(str){
	var res = expr.exec(str);
	if(isGood(res)) return res;
	throw JSON.stringify(res);
}

function Link(name){
	if(this instanceof Link); else return new Link(name);
	this.op = undefined; // паттерн
	if(typeof name !== 'string'){
		this.link = name; // паттерн для точного соответствия
		if(name instanceof Link)
			this.name = '['+name.name+']';
	}
	else this.name = name;
	return this;
}
function MatchError(){
	if(this instanceof MatchError);else return MatchError.apply(Object.create(MatchError.prototype),arguments)//throw 'you are fogot new';
	this.OK = arguments.length==0;
	if(this.OK)	return this;
	var args = Array.prototype.slice.call(arguments);
	this.what = args.shift();
	this.args = args;
	return this;
}
OK = MatchError();
MatchError.prototype.print = function(){
	if(this.OK) return 'OK'
	var str = this.what +': ';
	for(var i=0; i<this.args.length; i++)
		str += printOp(this.args[i])+', '
	return str.slice(0,str.length-2);
}
function eq_tree(op,pattern){
	//рекурсивно сравниваем вплоть до адресов линков - они должны совпасть
	if(op===pattern) return OK;
	if(pattern instanceof Link || op instanceof Link) return MatchError('different links',op,pattern);
	if(pattern instanceof Op && op instanceof Op);else throw 'unexpected type of pattern or op';
	if(pattern.which!=op.which) return MatchError('different operations in links',op,pattern);
	if(op.which=='!')
		return eq_tree(op.args[0],pattern.args[0])
	else if(op.which=='||'){
		var x = eq_tree(op.args[0],pattern.args[0]);
		if(!x.OK) return x;
		return eq_tree(op.args[1],pattern.args[1]);
	}
	else throw 'unexpected op\'s type "'+op.which+'"';
}
function matchOp(op,pattern){
	//рекурсивно сравниваем вплоть до линка в паттерне
	if(pattern instanceof Op && op instanceof Link)	return MatchError('very short op',op,pattern);
	if(pattern instanceof Op && op instanceof Op)
		if(op.which!=pattern.which)	return MatchError('different operations',op,pattern);
		else if(op.which=='!')
				return matchOp(op.args[0],pattern.args[0])
			else if(op.which=='||'){
				var x = matchOp(op.args[0],pattern.args[0]);
				if(!x.OK) return x;
				return matchOp(op.args[1],pattern.args[1]);
			}
			else throw 'unexpected op\'s type "'+op.which+'"';
	if(pattern instanceof Link);else throw 'unexpected type of pattern';

	if(pattern.link!==undefined)
		return eq_tree(op,pattern.link)
	if(pattern.op===undefined) {
		pattern.op=op;
		return OK;
	}
	else
		return eq_tree(op,pattern.op)
}

function Tau(link,op){
	if(this instanceof Tau);else return new Tau(link,op);
	this.link=link;
	this.op=op;
}
function Replace(to,from,op){
	if(this instanceof Replace);else return new Replace(to,from,op);
	this.to=to;
	this.from=from;
	this.op=op;
}

var printArray = [];
	printArray.push(function(op,parent_prio) { // !
		var cur_prio = 0;
		if(op.which=='!') 
			return '!'+printOp(op.args[0],cur_prio);
	});
	printArray.push(function(op,parent_prio) { // ||
		var cur_prio = 1;
		if(op.which=='||'){
			if(parent_prio<=cur_prio)	return '('+printOp(op.args[0],cur_prio)+'||'+printOp(op.args[1],cur_prio)+')';
			else return printOp(op.args[0],cur_prio)+'||'+printOp(op.args[1],cur_prio);
		}
	})
	printArray.push(function(op,parent_prio) { // =>
		var cur_prio = 3;
		if(op.which=='||' && op.args[0] instanceof Op && op.args[0].which=='!') {
			if(parent_prio<=cur_prio)	return '('+printOp(op.args[0].args[0],cur_prio)+'=>'+printOp(op.args[1],cur_prio)+')';
			else return printOp(op.args[0].args[0],cur_prio)+'=>'+printOp(op.args[1],cur_prio);
		}
	})
function printOp(op,parent_prio){
	if(op instanceof Link)	return op.name;
	if(op instanceof Op);else return '( '+JSON.stringify(op)+' )';
	parent_prio = parent_prio===undefined ? 100 : parent_prio;
	for(var i=printArray.length-1; i>=0; i--){
		var res = printArray[i](op,parent_prio)
		if(res) return res;
	}
	{
		var strArr = [];
		for(var i=0; i<op.args.length; i++)
			strArr.push(printOp(op.args[i]));
		return '('+op.which+' '+strArr.join(' ')+')'
	}
	//throw 'unknown operation';
}
Op.prototype.toJSON = function(){
	return printOp(this);
}

function Theoreme(links,st,name){
	if(this instanceof Theoreme);else return new Theoreme(links,st);
	this.links=links;
	this.st=st;
	this.name = name;
}

//==============================================================
var DBconstructor = function(){this.nest=0;}
Object.setPrototypeOf(DBconstructor.prototype, Array.prototype);
DB = new DBconstructor();

// то же, что console.log, только с отступом
	function hide($li,$list){
		$list.hide().addClass('hidden');
		$li.prepend('<span>&lt...&gt </span>');
	}
	function show($li,$list){
		$list.show().removeClass('hidden');
		$li.children().first().remove();
	}
function show_all(){
	$('li').each((index,li)=>{
		var $li = $(li)
		var $list = $li.children().last();
		if($list.length)
			if($list.hasClass('hidden'))	show($li,$list)
	})
}
function hide_all(){
	$('li').each((index,li)=>{
		var $li = $(li)
		var $list = $li.children().last();
		if($list.length)
			if(!$list.hasClass('hidden'))	hide($li,$list)
	})
}
DBconstructor.prototype.log = function(){
	if(this.log_disable) return;
	/*
	var tabs = '';
	for(var i=0; i<this.nest; i++) tabs+='\t';
	arguments[0] = tabs+arguments[0];
	*/
	if(this.nest==0)
		console.log.apply(console,arguments);
	
	var $list = $('#list');
	for(var i=0; i<this.nest; i++){
		var $li = $list.children().last();
		if($li.has('ul').length==0){
			$li.append('<ul></ul>');
			hide($li,$li.children().last())
		}
		$list = $li.children().last();
	}
	$('<li>'+arguments[0]+'</li>').appendTo($list).click(function(event){
		var $li = $(this)
		var $list = $li.children().last();
		if($list.length){
			if($list.hasClass('hidden'))	show($li,$list)
			else							hide($li,$list)
		}
		event.stopPropagation();
	})
}
// преобразование теоремы в строку
DBconstructor.prototype.print = function(i){
	return '['+i+']'+(this[i].name?this[i].name:'')+': '+printOp(this[i].st);
}
DBconstructor.prototype.shortPrint = function(i){
	return '['+i+']'+(this[i].name?this[i].name:'');
}

function addLinks(links,op){
	if(op instanceof Link){
		if(links.indexOf(op)==-1)links.push(op);
		return;
	}
	if(op instanceof Op);else throw 'unknown type';
	if(op.which=='!') addLinks(links,op.args[0])
	else if(op.which=='||'){
		addLinks(links,op.args[0]);
		addLinks(links,op.args[1]);
	}
	else throw 'unknown op ('+op.which+')';
}
DBconstructor.prototype.addAxiom = function(st,name){
	if(typeof st === 'string') st = parse(st)
	to_n = this.find(st);
	if(to_n!=-1) {
		this.log('already exist '+printOp(st)+' : '+this.print(to_n));
		return {st:st, no:to_n};
	}
	
	var x = this.add(st,name);
	this.log('NEW AXIOME '+this.print(x.no));
	return x;
}
DBconstructor.prototype.add = function(st,name){

	var links = [];
	addLinks(links,st);
	var tmp = new Theoreme(links,st,name)
	this.push(tmp);
	return {st:st, no:this.length-1};
}

function ProveError(what){
	Error.call(this, what);
	this.message = what;
	this.name = 'ProveError';
	if (Error.captureStackTrace) {
		Error.captureStackTrace(this, ProveError);
	}
	else {
		this.stack = (new Error()).stack;
	}
}
ProveError.prototype = Object.create(Error.prototype);
function ManualProveError(what){
	Error.call(this, what);
	this.message = what;
	this.name = 'ManualProveError';
	if (Error.captureStackTrace) {
		Error.captureStackTrace(this, ManualProveError);
	}
	else {
		this.stack = (new Error()).stack;
	}
}
ManualProveError.prototype = Object.create(Error.prototype);

DBconstructor.prototype.find = function(from,hint_no){
	var self = this;
	function check(n){
		//console.log('check '+n)
		if(self.no_scheme) return eq_tree(from,self[n].st);// for makeTheoreme
		self[n].links.forEach((link)=>{link.op=undefined})
		return matchOp(from,self[n].st);
	}
	if(hint_no!==undefined){
		if((typeof hint_no)!='number' || hint_no<0 || hint_no>=this.length)
			throw new ProveError('bad hint_no: '+JSON.stringify(hint_no))
		var err;
		if((err = check(hint_no)).OK)
			return hint_no;
		else{
			this.log(err.print()+' - in compare to '+printOp(this[hint_no].st));
			return -1;
		}
	}
	var errors=[];
	for(var i=this.length-1; i>=0; i--) { // здесь реально пригодятся хеши
		var err;
		if((err=check(i)).OK){
			//this.log(printOp(from)+' match to '+printOp(this[i].st))
			return i;
		}
		errors.push(err);
	}
	//if(!DB.verbose)	
	return -1;
	for(var i=0; i<errors.length; i++){
		this.log(errors[i].print()+' - in compare to '+printOp(this[i].st));
	}
	return -1;
}
DBconstructor.prototype.check = function(st,hint){
	if(typeof st === 'string') st = parse(st)
	var i = hint ? this.find(st,hint.no) : this.find(st);
	if(i==-1)	throw new ProveError('no matches: '+printOp(st));
	else this.log(printOp(st)+' match to '+this.print(i));
	return {st:st, no:i};
}
DBconstructor.prototype.prove = function(from, to, {from:from_no_obj, because:because_no_obj, name}={}){
	if(typeof from === 'string') from = parse(from)
	if(typeof to === 'string') to = parse(to)
	// проверка подсказок
	var from_n;
	if(from_no_obj){
		if(typeof from_no_obj =='object' && 'no' in from_no_obj){
			from_n = this.find(from,from_no_obj.no);
			if(from_n==-1){
				if(this.verbose)
					this.log('can\'t from '+printOp(from)+' prove '+printOp(to))
				throw new ProveError('"from" ('+printOp(from)+') don\'t match specified '+this.print(from_no_obj.no));
			} 
		}
		else throw 'from_no_obj has no "no" member';
	}
	var because_n;
	if(because_no_obj){
		if(typeof because_no_obj =='object' && 'no' in because_no_obj){
			because_n = this.find(imp(from,to),because_no_obj.no);
			if(because_n==-1){
				if(this.verbose)
					this.log('can\'t from '+printOp(from)+' prove '+printOp(to))
				throw new ProveError('imp("from","to") ('+printOp(imp(from,to))+') don\'t match specified '+
					this.print(because_no_obj.no));
			} 
		}
		else throw 'because_no_obj has no "no" member';
	}
	
	// проверка на already exist
	to_n = this.find(to);
	if(to_n!=-1) {
		this.log('already exist '+printOp(to)+' : '+this.print(to_n)+
			(!from_no_obj?' from undefined ':
				' from '+this.shortPrint(from_n))+
			(!because_no_obj?' because undefined ':
				' because '+this.shortPrint(because_n)));
		return {st:to, no:to_n};
	}

	// поиск
	if(from_n===undefined){
		from_n = this.find(from);
		if(from_n==-1){
			if(this.verbose)
				this.log('can\'t from '+printOp(from)+' prove '+printOp(to))
			throw new ProveError('can not find "from": '+printOp(from));
		} 
	}
	if(because_n===undefined){
		because_n = this.find(imp(from,to));
		if(because_n==-1){
			if(this.verbose)
				this.log('can\'t from '+printOp(from)+' prove '+printOp(to))
			throw new ProveError('can not find imp("from","to"): '+printOp(imp(from,to)));
		} 
	}
	
	// попытки упростить
	var from_ = from;
	var to_ = to;
	var changed = false;
	this.log_disable = true;
	while(true){
		var simplified = simplify(imp(from,to));
		if(!simplified || 
			!(simplified instanceof Op) ||
			simplified.which!='||' ||
			!(simplified.args[0] instanceof Op) ||
			simplified.args[0].which!='!'
			)	break;
		
		if(this.find(simplified.args[0].args[0],from_n)==-1 ||
			this.find(simplified,because_n)==-1){
				if(0){ // осень часто неудачные
					this.log_disable = false;
					this.log('simplify is failed ('+printOp(from_)+' => '+printOp(to_)+
						') --> ('+printOp(simplified.args[0].args[0])+' => '+printOp(simplified.args[1])+')');
				}
				break;
		}
		changed = true;
		from = simplified.args[0].args[0];
		to = simplified.args[1];
	}
	this.log_disable = false;
	if(changed)
		this.log('simplified (('+printOp(from_)+') => ('+printOp(to_)+')) --> (('+printOp(from)+') => ('+printOp(to)+'))');
	
	// добавляем, сообщаем
	var x = this.add(to,name);
	this.log('prove '+this.print(x.no)+
		(!from_no_obj?' from found '+this.print(from_n):
			this.verbose?' (from '+this.print(from_n)+')':' from '+this.shortPrint(from_n))+
		(!because_no_obj?' because found '+this.print(because_n):
			this.verbose?' (because '+this.print(because_n)+')':' because '+this.shortPrint(because_n))
	);
	/*
	for(var i=0; i<this.length; i++)
		console.log(this.print(i))
	*/
	return x;
}

	function forEachSubset(set,fun/*(subset)*/) { // по всем подмножествам (кроме пустого)
		var set_switch = [];
		for(var x in set)
			set_switch.push({name:x,enabled:false})
		function next_subset(st_sw){
			for(var i=0; i<st_sw.length; i++)
				if(st_sw[i].enabled)
					st_sw[i].enabled = false
				else{
					st_sw[i].enabled = true;
					return true;
				}
			return false;
		}
		for(;next_subset(set_switch);){
			var subset={};
			for(var i =0; i<set_switch.length; i++)// копируем в subset
				if(set_switch[i].enabled)
					subset[set_switch[i].name] = set[set_switch[i].name];
			fun(subset);
		}
	}
	function GCD(m,n) { // НОД двух чисел
		var factor = 1;
		while(true){
			//НОД(0, n) = n; НОД(m, 0) = m; НОД(m, m) = m;
			if(m==n)
				if(m==0)	throw 'GCD(0,0)'
				else return factor*m;
			if(m==0)	return factor*n;
			if(n==0)	return factor*m;
			//НОД(1, n) = 1; НОД(m, 1) = 1;
			if(m==1 || n==1)	return factor;
			//Если m, n чётные, то НОД(m, n) = 2*НОД(m/2, n/2);
			if(!(m&1) && !(n&1)){
				factor<<=1;
				m>>=1;
				n>>=1;
			}
			//Если m чётное, n нечётное, то НОД(m, n) = НОД(m/2, n);
			else if(!(m&1)) m>>=1;
			//Если n чётное, m нечётное, то НОД(m, n) = НОД(m, n/2);
			else if(!(n&1)) n>>=1;
			//Если m, n нечётные и n > m, то НОД(m, n) = НОД((n-m)/2, m);
			else if(n>m) n = (n-m)>>1;
			//Если m, n нечётные и n < m, то НОД(m, n) = НОД((m-n)/2, n);			
			else m = (m-n)>>1;
		}
	}
	function GCD_obj(obj) { // НОД свойств объекта
		var nod;
		for(var x in obj){
			nod = obj[x];
			break;
		}
		for(var x in obj)
			nod = GCD(nod,obj[x]);
		return nod;
	}
	function forEachDivisor(N,fun/*(divisor)*/) { // по всем делителям (кроме 1)
		var simple_divs = [];
		for(var i=2; i*i<=N; i++)//разбиваем N на простые множетели
			if(N%i==0){
				simple_divs.push({divisor:i,power:1,used:0});
				N/=i;
				while(N%i==0){
					simple_divs[simple_divs.length-1].power++;
					N/=i;
				}
			}
		if(N>1) simple_divs.push({divisor:N,power:1,used:0});
		function next_divisor(sd){
			for(var i=0; i<sd.length; i++)
				if(sd[i].used==sd[i].power)
					sd[i].used = 0
				else{
					sd[i].used++;
					return true;
				}
			return false;
		}
		for(;next_divisor(simple_divs);){
			var divisor = 1;
			for(var i =0; i<simple_divs.length; i++)
				divisor*=Math.pow(simple_divs[i].divisor,simple_divs[i].used);
			fun(divisor);
		}
	}
function simplify(tree){ // находит поддерево, повторяющееся 2 или более раз, такое, что 
	// переменные этих поддеревьев не содержатся вне этих поддеревьев
	// заменяет эти поддеревья на одну переменную, и возвращает измененное дерево
	// если не находит, возвращает undefined
	function forEachSubtree(op,fun/*(op,stat)*/) { // return {size:n,stat:{[name]:m...}}
		if(op instanceof Link){
			var link_stat = {};
			link_stat[op.name] = 1;
			return {size:1,stat:link_stat};
		}
		else if(op instanceof Op);else throw 'unknown type';
		var stat;
		if(op.which=='!'){
			var stat = forEachSubtree(op.args[0],fun);
			stat.size++;
		}
		else if(op.which == '||'){
			var stat = forEachSubtree(op.args[0],fun)
			var stat2 = forEachSubtree(op.args[1],fun)
			stat.size += stat2.size+1;
			for(var x in stat2.stat){
				if(x in stat.stat)
					stat.stat[x]+=stat2.stat[x];
				else
					stat.stat[x] =stat2.stat[x];
			}
		}
		else throw 'unknown op ('+op.which +')'
		if(fun) fun(op,stat);
		return stat;
	}
	function stat2string(stat) { // сортирует и в строку
		var strs = [];
		for(var x in stat)
			strs.push(x+':'+stat[x]);
		return strs.sort().join(';')
	}
	function makeResonablePredGroups(stat) { // формируем допустимые конфигурации для предгрупп
		var predGroups = {}; 
		forEachSubset(stat,function(sub_stat) {
			var nod = GCD_obj(sub_stat);
			if(nod>1)
				forEachDivisor(nod,function(d){
					var tmp_stat={}
					for(var x in sub_stat)
						tmp_stat[x] = sub_stat[x]/d;
					predGroups[stat2string(tmp_stat)]={}
				})
		})
		return predGroups;
	}
	function PredGroup(stat,size){
		this.stat = stat;
		this.size = size;
	}
	Object.setPrototypeOf(PredGroup.prototype, Array.prototype);
	PredGroup.prototype.toJSON = function(){
		var strings = [];
		for(var i=0; i<this.length; i++)
			strings.push(printOp(this[i].op));
		return '('+this.size+','+stat2string(this.stat)+')['+strings.join(',')+']';
	}
	function fillPredGroups(tree,predGroups) { // добавляем поддеревья в предгруппы (создаем, если их нет)
		var doSequence = []; 
		forEachSubtree(tree,function(op,stat){
				//console.log(printOp(op)+' -before')
				//console.log(JSON.stringify(predGroups))
				//console.log(JSON.stringify(doSequence))
			var statStr = stat2string(stat.stat);
			if(statStr in predGroups){
				var predGroupArr = predGroups[statStr];
				if(stat.size in predGroupArr){
					predGroupArr[stat.size].push({op:op,used:false})
					for(var x in stat.stat)
						console.assert(predGroupArr[stat.size].stat[x] == stat.stat[x]);
					console.assert(predGroupArr[stat.size].size == stat.size);
				}
				else{
					var tmp_stat = {};
					for(var x in stat.stat)
						tmp_stat[x] = stat.stat[x];
					predGroupArr[stat.size] = new PredGroup(tmp_stat,stat.size)
					predGroupArr[stat.size].push({op:op,used:false})
					if(stat.size in doSequence)
						doSequence[stat.size].push(predGroupArr[stat.size])
					else
						doSequence[stat.size] = [predGroupArr[stat.size]];
				}
			}
				//console.log(printOp(op)+' -after')
				//console.log(JSON.stringify(predGroups))
				//console.log(JSON.stringify(doSequence))
		})
		return doSequence;
	}
	function sortCompressDoSequence(doSequence) { // сортируем предГруппы по размеру
		var doSequence2 = [];
		for(var x in doSequence)
			doSequence2.push(x);
		doSequence2.sort();
		for(var i =0; i<doSequence2.length; i++)
			doSequence2[i] = doSequence[doSequence2[i]]
		return doSequence2;
	}
	function findGroup(doSequence,treeStat) { // ищем группу
		for(var seq_i=0; seq_i<doSequence.length; seq_i++) // начиная с самых маленьких поддеревьев
			for(var seq_j=0; seq_j<doSequence[seq_i].length; seq_j++){
				var predGroup = doSequence[seq_i][seq_j]; // предГруппа
				
				var x; for(x in predGroup.stat) break;
				console.assert(treeStat[x]%predGroup.stat[x]==0);
				var needed = treeStat[x]/predGroup.stat[x]; // сколько требуется поддеревьев
				console.assert(needed>1);
				var left = predGroup.length; // сколько поддеревьев из предгруппы не использовано
				while(left>=needed){ 
					var group = []; // начинаем формировать группу
					var k;
					for(k=0; k<predGroup.length; k++) // ищем первый элемент группы
						if(!predGroup[k].used){
							group.push(predGroup[k].op);
							predGroup[k].used = true;
							left--;
							break;
						}
					var etalone = predGroup[k].op;
					for(k++; k<predGroup.length && // по всей предГруппе
							left+group.length>=needed && // пока есть возможность набрать группу
							group.length<needed // пока группа не набрана
							; k++) // из предГруппы формируем группу
						if(!predGroup[k].used && eq_tree(predGroup[k].op,etalone).OK) {
							group.push(predGroup[k].op);
							predGroup[k].used = true;
							left--;
						}
					if(group.length==needed)
						return group;
				}
			}
		return undefined;
	}
	function replaceGroup(group,tree) { // заменяет поддеревья из группы на переменную 
		// в первом поддереве группы найти Link
		var op;
		for(op = group[0]; op instanceof Op && op.which=='!' || op.which=='||'; op = op.args[0]) ;
		var link = op;
		// в корнях всех поддеревьев группы заменить which на другое
		for(var i=0; i<group.length; i++)
			group[i].replace = true;
		// по всему дереву узлы с другим which заменить на link
		function replaceOp(op){
			if(op instanceof Op){
				if(op.which=='||'){
					var a,b;
					if(op.args[0] instanceof Op && op.args[0].replace){
						delete op.args[0].replace;
						a = link;
					}
					else
						a = replaceOp(op.args[0]);
					//else throw 'replace link'
					if(op.args[1] instanceof Op && op.args[1].replace){
						delete op.args[1].replace;
						b = link;
					}
					else
						b = replaceOp(op.args[1]);
					//else throw 'replace link'
					return or(a,b);
				}
				else if(op.which=='!'){
					var a;
					if(op.args[0] instanceof Op && op.args[0].replace){
						delete op.args[0].replace;
						a = link;
					}
					else
						a = replaceOp(op.args[0]);
					return not(a);
					//else throw 'replace link'
				}
				else throw 'unknown op ('+op.which+')';
				throw 'not return 2';
			}
			else if(op instanceof Link)
				return op;
			else throw 'unknown type';
			throw 'not return 1';
		}
		return replaceOp(tree);
	}

	var changed = false;
	var treeStat = forEachSubtree(tree).stat;
	var predGroups = makeResonablePredGroups(treeStat); 
		// объект, каждая строка stat индексирует 
		// объект(массив предГрупп), в котором каждый размер поддерева индексирует 
		// массив(предГруппа), набор из
			// объект
				// op - ссылку на поддерево
				// used - использовалось ли в группе
		// и свойства
			// stat
			// size
	var doSequence = fillPredGroups(tree,predGroups); 
		// массив, каждый размер поддерева индексирует, а птом просто набор из
		// массив, набор из
		// указатель на предГруппу
	//console.log(JSON.stringify(predGroups))
	//console.log(JSON.stringify(doSequence))
		
	doSequence = sortCompressDoSequence(doSequence);
	//console.log(JSON.stringify(doSequence))
	var group = findGroup(doSequence,treeStat)
		//массив ссылок на дерево
	if(group){
		/*
		var strArr = []
		for(var i=0; i<group.length; i++)
			strArr.push(printOp(group[i]));
		console.log(strArr.join(','))
		*/
		var new_tree = replaceGroup(group,tree);
		//console.log(printOp(tree))
		//changed = true;
		//if(eq_tree(tree,new_tree).OK)
			//console.log('SIMPLIFY don\'t change: '+printOp(tree)+' '+printOp(new_tree))
		return new_tree;
	} 
	else 
		return undefined;
}
DB.log('============================ $3 Логические теории')

DB.log('---------------------------- п1 Аксиомы')

var links = {
	A: new Link('A'),
	B: new Link('B'),
	B_: new Link('B_'),
	C: new Link('C'),
	D: new Link('D')
};
var A = links.A;
var B = links.B;
var B_ = links.B_;
var C = links.C;
var D = links.D;

var S1 = DB.addAxiom('A||A=>A','S1')
var S2 = DB.addAxiom('A=>A||B','S2')
var S3 = DB.addAxiom('A||B=>B||A','S3')
var S4 = DB.addAxiom('(A=>B)=>(C||A=>C||B)','S4')

function makeRule(name,description,target,fun){
	return function(links,hints={}){
		var strs = [];
		for(var i=0; i<links.length; i++){
			if(typeof links[i] ==='string')
				links[i] = parse(links[i]);
			strs.push(printOp(links[i]));
		}
		var tmp;
		var trg = target(links);
		DB.log(hints.name+': '+printOp(trg)+' _by_ '+name+' ['+strs.join(',')+'] '+description);
		DB.nest++;
			try{
				tmp = DB.check(trg)
				var str;
				if(tmp instanceof Array){
					str = tmp[tmp.length-1]
					str = '('+(tmp.length-1)+')'+printOp(tmp.st)
				}
				else str = DB.print(tmp.no)
				DB.log('fast exist '+str)
			}
			catch(err){
				if(err instanceof ProveError){
					hints.already_checked = DB.length
					tmp = fun(links,hints);
				}
				else throw err;
			}
		DB.nest--;
		return tmp;
	}
}

DB.contradiction = makeRule('contradiction','A; !A -> B',([A,B])=>B, ([A,B],{True,False,name}={})=>{
	var x = DB.prove(not(A),imp(A,B),{from:False, because:S2, name:'contradiction.'+name});
	return DB.prove(A,B,{from:True, because:x, name});
})

DB.log('---------------------------- п2 Первые следствия')

DB.C6 = makeRule('C6','A=>B; B=>C -> A=>C',([A,B,C])=>imp(A,C), ([A,B,C],{first,second,name}={})=>{
	var x = DB.prove(imp(B,C),imp(imp(A,B),imp(A,C)),{from:second, because:S4, name:'C6.'+name});
	return DB.prove(imp(A,B),imp(A,C),{from:first, because:x, name});
})
var C7 = DB.C6([A,or(A,B),or(B,A)],{first:S2, second:S3, name:'C7'}); // A=>B||A
var C8 = DB.C6([A,or(A,A),A],{first:S2, second:S1, name:'C8'}); // A=>A
DB.C9 = makeRule('C9','B -> A=>B',([A,B])=>imp(A,B), ([A,B],{to,name}={})=>{
	return DB.prove(B,imp(A,B),{from:to, because:C7, name});
})
var C10 = DB.prove('A=>A','A||!A',{from:C8, because:S3, name:'C10'})
var C11 = DB.check('A=>!!A', C10);
var C12_pre = DB.prove('B=>!!B','!A||B=>!A||!!B',{from:C11, because:S4, name:'C12_pre'})
var C12 = DB.C6(['!A||B','!A||!!B','!B=>!A'],{first:C12_pre, second:S3, name:'C12'}) // (A=>B)=>(!B=>!A)
var C13_pre = DB.prove('C||!A=>!A||C','(!B||C=>C||!A)=>(!B||C=>!A||C)',{from:S3, because:S4, name:'C13_pre'});
DB.C13 = makeRule('C13','A=>B -> (B=>C)=>(A=>C)',([A,B,C])=>imp(imp(B,C),imp(A,C)), ([A,B,C],{from,name}={})=>{
	var x = DB.prove(imp(A,B),imp(not(B),not(A)),{from:from, because:C12, name:'C13_1.'+name});
	x = DB.prove(imp(not(B),not(A)),imp(or(C,not(B)),or(C,not(A))),{from:x, because:S4, name:'C13_2.'+name})
	x = DB.C6([or(not(B),C),or(C,not(B)),or(C,not(A))],{first:S3, second:x, name:'C13_3.'+name});
	return DB.prove(imp(imp(B,C),or(C,not(A))),imp(imp(B,C),imp(A,C)),{from:x, because:C13_pre, name});
})
var x = DB.C13([imp(B,C),'C||!B','C||!A'],  {from:S3, name:'My1_pre1'})
var y = DB.C6(['A=>B','!B=>!A','C||!B=>C||!A'], {first:C12, second:S4, name:'My1_pre2'})
x = DB.C6(['A=>B','C||!B=>C||!A','(B=>C)=>C||!A'], {first:y, second:x, name:'My1_pre3'})
DB.C6(['A=>B','(B=>C)=>C||!A','(B=>C)=>(A=>C)'], {first:x, second:C13_pre, name:'My1'})

DB.log('---------------------------- п3 Методы доказательства')

var C14_pre = DB.prove('!A=>(A=>B_)','((A=>B_)||!A)=>((A=>B_)||(A=>B_))', {from:S2, because:S4, name:'C14_pre'});
DB.C14 = makeRule('C14','A=>B; A=>(B=>B_) -> A=>B_',([A,B,B_])=>imp(A,B_), ([A,B,B_],{from,because,name}={})=>{
	var x = DB.C13([A,B,B_],{from:from, name:'C14_1.'+name});
	x = DB.C6([A,imp(B,B_),imp(A,B_)],{first:because, second:x, name:'C14_2.'+name});
	x = DB.prove(imp(A,imp(A,B_)),or(imp(A,B_),not(A)), {from:x, because:S3, name:'C14_3.'+name});
	x = DB.prove(or(imp(A,B_),not(A)),or(imp(A,B_),imp(A,B_)), {from:x, because:C14_pre, name:'C14_4.'+name});
	return DB.prove(or(imp(A,B_),imp(A,B_)),imp(A,B_), {from:x, because:S1, name:name});
})
function makeTheoreme(pr_name,premise/*не схема*/,conseq,links,fun,hints={}) {
	if(typeof premise === 'string') premise = parse(premise);
	if(typeof conseq === 'string') conseq = parse(conseq);
	var real_prove = DB.prove;
	var real_check = DB.check;
	var subDBs = makeTheoreme.subDBs;
	var level = subDBs.length;
	
	function hint_pop(hint){
		if(level==0 && hint instanceof Array)
			return hint[0];
		else if(hint instanceof Array)
			while(hint.length > level+1)
				hint.pop()
		return hint;
	}
	function hint_push(hint,x,level){
		if(!(hint instanceof Array)) hint = [hint]
		if(hint[level+1] !==undefined) throw 'overwrite in hint'
		hint[level+1] = x;
		return hint;
	}
	
	/*
	 * hint в стеке теорий - стек hint-ов в каждой теории, 
	 * но может содержать пропуски:
	 * undefined говорит о том, что на данном уровне теоремы нет (и ее искать не стоит на данном уровне)
	 * null говорит, что на данном уровне может находиться теорема
	 */
	function is_fake(st,hint) { // если есть в верхней DB, то тоже, что check, иначе вернет undefined
		if(hint){
			if(hint[level+1]){
				hint[level+1] = subDBs[level].check(st,hint[level+1])
				return hint;
			}
			else if(hint[level+1]===null){
				try{
					hint[level+1] = subDBs[level].check(st)
					return hint;
				}
				catch(err){if(err instanceof ProveError){
						hint[level+1] = undefined;
						return undefined;
					}
					else throw err;
				}
			}
			else return undefined;
		}
		else{
			hint = [];
				try{
					hint[level+1] = subDBs[level].check(st)
					for(var i=0; i<=level; i++)
						hint[i] = null;
					return hint;
				}
				catch(err){if(err instanceof ProveError){
						return undefined;
					}
					else throw err;
				}
		}
		throw 'not implemented'
	}
	
	function fake_check(st,hint){
		if(typeof st === 'string') st = parse(st)
		var res = is_fake(st,hint);
		if(res) return res;
		DB.prove = real_prove;
		DB.check = real_check;
			try{
				res = DB.check(st,hint_pop(hint));
			}
			catch(err){
				if(err instanceof ProveError){
					DB.prove = fake_prove;
					DB.check = fake_check;
				}
				throw err;
			}
		DB.prove = fake_prove;
		DB.check = fake_check;
		return res;
	}
	function fake_prove(from,to,{from:from_hint, because:because_hint, name}={}){
		if(typeof from === 'string') from = parse(from)
		if(typeof to === 'string') to = parse(to)
			
		var from_fake = is_fake(from,from_hint)
		var because_fake = is_fake(imp(from,to),because_hint);
		var res;
		
		/*
		 *	from	because
		 
		 *	real	real	real_prove
		 *	   B;     B=>C  ->    C
		 
		 *	fake	real	C6
		 *	A=>B;     B=>C  -> A=>C
		 
		 *	real	fake	prove_proved+C14
		 *	   B; A=>(B=>C) -> A=>C
		 
		 *	fake	fake	C14
		 *	A=>B; A=>(B=>C) -> A=>C
		 */
		if(because_fake) { // C14
			if(!from_fake) { // proved
				DB.log('fake_prove('+level+')proved: from '+printOp(from)+' to '+printOp(to))
				DB.nest++;
					DB.prove = real_prove;
					DB.check = real_check;
						from_fake = DB.prove(from,imp(premise,from),{from:hint_pop(from_hint), because:C7, name:'prove_proved '+name})
						from_fake = hint_push(from_fake,subDBs[level].add(from,'proved '+name),level);
					DB.prove = fake_prove;
					DB.check = fake_check;
				DB.nest--;
			}
				DB.log('fake_prove('+level+')C14: from '+printOp(from)+' to '+printOp(to))
				DB.nest++;
					DB.prove = real_prove;
					DB.check = real_check;
						res = DB.C14([premise,from,to],{from:hint_pop(from_fake), because:hint_pop(because_fake), name})
						res = hint_push(res,subDBs[level].add(to,name),level);
					DB.prove = fake_prove;
					DB.check = fake_check;
				DB.nest--;
		}
		else
			if(from_fake) { // C6
				DB.log('fake_prove('+level+')C6: from '+printOp(from)+' to '+printOp(to))
				DB.nest++;
					DB.prove = real_prove;
					DB.check = real_check;
						res = DB.C6([premise,from,to],{first:hint_pop(from_fake), second:hint_pop(because_hint), name})
						res = hint_push(res,subDBs[level].add(to,name),level);
					DB.prove = fake_prove;
					DB.check = fake_check;
				DB.nest--;
			}
			else { // real
				DB.log('fake_prove('+level+')real: from '+printOp(from)+' to '+printOp(to))
				DB.nest++;
					DB.prove = real_prove;
					DB.check = real_check;
						res = DB.prove(from,to,{from:hint_pop(from_hint), because:hint_pop(because_hint), name})
					DB.prove = fake_prove;
					DB.check = fake_check;
				DB.nest--;
			}
		return res;
	}
	
	subDBs.push(new DBconstructor())
	subDBs[level].log_disable = true;
	subDBs[level].no_scheme = true;
	var pr_hint = [C8]; //A=>A
		pr_hint[level+1] = subDBs[level].add(premise,pr_name)
	hints[pr_name] = pr_hint;
		DB.log('makeTheoreme('+level+') from '+printOp(premise)+' to '+printOp(conseq)+' - '+hints.name);
		DB.nest++;
			DB.prove = fake_prove;
			DB.check = fake_check;
				var res = fun(links,hints);
			DB.prove = real_prove;
			DB.check = real_check;
		DB.nest--;
	subDBs[level].check(conseq,(res && res instanceof Array)?res[level+1]:undefined);
	subDBs.pop();
	return hint_pop(res);
}
makeTheoreme.subDBs = [];

DB.C15 = makeRule('C15','!A=>A -> A',([A])=>A, ([A],{from,name}={})=>{
	var x = DB.prove(imp(not(A),A),imp(or(A,not(A)),or(A,A)), {from:from, because:S4, name:'C15_internal_1'});
	x = DB.prove(or(A,not(A)),or(A,A), {from:C10, because:x, name:'C15_internal_2'});
	return DB.prove(or(A,A),A, {from:x, because:S1, name:name});
});
var C16 = makeTheoreme('nnA',not(not(A)),A, [A],([A],{nnA})=>{
	var x = makeTheoreme('nA',not(A),A, [A],([A], {nA})=>{
		return DB.contradiction([not(A),A],{True:nA, False:nnA, name:'C16_internal'});
	})
	return DB.C15([A], {from:x, name:'C16'});
});
var C17 = makeTheoreme('premise','!B=>!A','A=>B', [A,B],([A,B],{premise})=>{
	return makeTheoreme('_A',A,B, [A,B],([A,B],{_A})=>{
		var x = makeTheoreme('nB',not(B),B, [A,B],([A,B],{nB})=>{
			var x = DB.prove(not(B),not(A),{from:nB, because:premise, name:'C17_internal_1'});
			return DB.contradiction([A,B],{True:_A, False:x, name:'C17_internal_2'});
		})
		return DB.C15([B],{from:x, name:'C17'});
	})
});

DB.C18 = makeRule('C18','A||B; A=>C; B=>C -> C',([A,B,C])=>C, ([A,B,C],{diff,first,second,name})=>{
	var x = DB.prove(imp(B,C),imp(or(A,B),or(A,C)),{from:second,because:S4,name:'C18_internal_1'})
	var y = DB.prove(imp(A,C),imp(or(C,A),or(C,C)),{from:first,because:S4,name:'C18_internal_2'})
	x = DB.prove(or(A,B),or(A,C),{from:diff, because:x,name:'C18_internal_3'});
	x = DB.prove(or(A,C),or(C,A),{from:x, because:S3,name:'C18_internal_4'});
	x = DB.prove(or(C,A),or(C,C),{from:x, because:y,name:'C18_internal_5'});
	return DB.prove(or(C,C),C,{from:x, because:S1, name:name});
})

DB.log('---------------------------- п4 Коньюнкция')

function and(x,y){
	return not(or(not(x),not(y)));
}
	read_expr_and = (str,pos)=> read_any(str,pos,collect,[
		(str,pos)=>{
			var r = read_seq(str,pos,need(0,2),[read_expr_or,txt('&&').exec,read_expr_or]);
			if(!isGood(r)) return addErrMessage(r,' - in "expr&&expr"');
			return and(r[0],r[1]);
		},
		read_expr_or
	])
printArray.push(function(op,parent_prio) { // &&
	var cur_prio = 2;
	if(op.which=='!' 
		&& op.args[0] instanceof Op && op.args[0].which=='||'
		&& op.args[0].args[0] instanceof Op && op.args[0].args[0].which=='!'
		&& op.args[0].args[1] instanceof Op && op.args[0].args[1].which=='!'
	) {
		if(parent_prio<=cur_prio)
			return '('+printOp(op.args[0].args[0].args[0],cur_prio)+'&&'+printOp(op.args[0].args[1].args[0],cur_prio)+')';
		else return printOp(op.args[0].args[0].args[0],cur_prio)+'&&'+printOp(op.args[0].args[1].args[0],cur_prio);
	}
})
/*
var tmp = printArray[length-2];
printArray[length-2] = printArray[length-1];
printArray[length-1] = tmp;
*/

DB.C20 = makeRule('C20','A; B -> A&&B',([A,B])=>and(A,B), ([A,B],{first,second,name}={})=>{
	var x = makeTheoreme('contrary',not(and(A,B)),and(A,B),[A,B],([A,B],{contrary})=>{
		var x = DB.prove(not(and(A,B)),or(not(A),not(B)),{from:contrary,because:C16,name:'C20_internal_1.'+name})
		x = DB.prove(A,not(B),{from:first,because:x,name:'C20_internal_2.'+name});
		return DB.contradiction([B,and(A,B)],{True:second,False:x,name:'C20_internal_3.'+name});
	})
	return DB.C15([and(A,B)],{from:x,name:'C20'});
})

var x = DB.check('!A||!B=>!(A&&B)')
var y = DB.C6(['!A','!A||!B','!(A&&B)'],{first:S2,second:x,name:'C21_L_pre'})
var C21_L = DB.prove(y.st,'A&&B=>A',{from:y,because:C17,name:'C21_L'})
var y = DB.C6(['!B','!A||!B','!(A&&B)'],{first:C7,second:x,name:'C21_R_pre'})
var C21_R = DB.prove(y.st,'A&&B=>B',{from:y,because:C17,name:'C21_R'})

DB.log('---------------------------- п5 Эквивалентность')

function eql(a,b){
	return and(imp(a,b),imp(b,a));
}
	var read_expr_eql = (str,pos)=> read_any(str,pos,collect,[
		(str,pos)=>{
			var r = read_seq(str,pos,need(0,2),[read_expr_imp,txt('<=>').exec,read_expr_imp]);
			if(!isGood(r)) return addErrMessage(r,' - in "expr=>expr"');
			return eql(r[0],r[1]);
		},
		read_expr_imp
	])
expr = new Pattern(read_expr_eql);
printArray.push(function(op,parent_prio) { // <=>
	var cur_prio = 3;
	function selectOp(){
		var op = arguments[0]
		for(var i =1; i<arguments.length; i++)
			op = op.args[arguments[i]];
		//arguments[0] = -1
		//console.log(JSON.stringify(arguments) + printOp(op))
		return op;
	}
	if(op.which=='!' 
		&& selectOp(op,0) instanceof Op && selectOp(op,0).which=='||'
		&& selectOp(op,0,0) instanceof Op && selectOp(op,0,0).which=='!'
		&& selectOp(op,0,1) instanceof Op && selectOp(op,0,1).which=='!'
		&& selectOp(op,0,0,0) instanceof Op && selectOp(op,0,0,0).which=='||'
		&& selectOp(op,0,1,0) instanceof Op && selectOp(op,0,1,0).which=='||'
		&& selectOp(op,0,0,0,0) instanceof Op && selectOp(op,0,0,0,0).which=='!'
		&& selectOp(op,0,1,0,0) instanceof Op && selectOp(op,0,1,0,0).which=='!'
		&& eq_tree(selectOp(op,0,0,0,0,0),selectOp(op,0,1,0,1)).OK
		&& eq_tree(selectOp(op,0,1,0,0,0),selectOp(op,0,0,0,1)).OK
	) {
		if(parent_prio<=cur_prio)
			return '('+printOp(selectOp(op,0,1,0,1),cur_prio)+'<=>'+printOp(selectOp(op,0,0,0,1),cur_prio)+')';
		else return printOp(selectOp(op,0,1,0,1),cur_prio)+'<=>'+printOp(selectOp(op,0,0,0,1),cur_prio);
	}
})

DB.C22_1 = makeRule('C22-1','A<=>B -> B<=>A',([A,B])=>eql(B,A), ([A,B],{from,name}={})=>{
	DB.prove(eql(A,B),imp(A,B))
	DB.prove(eql(A,B),imp(B,A))
	DB.C20([imp(B,A),imp(A,B)])
})
var C22_1 = makeTheoreme('prem','A<=>B','B<=>A',[A,B],DB.C22_1)
DB.C22_2 = makeRule('C22-2','A<=>B; B<=>C -> A<=>C',([A,B,C])=>eql(A,C), ([A,B,C],{first,second,name}={})=>{
	DB.prove(eql(A,B),imp(A,B))
	DB.prove(eql(A,B),imp(B,A))
	DB.prove(eql(B,C),imp(B,C))
	DB.prove(eql(B,C),imp(C,B))
	DB.C6([A,B,C])
	DB.C6([C,B,A])
	DB.C20([imp(A,C),imp(C,A)]);
})
var C22_2 = makeTheoreme('prem','A<=>B','(B<=>C)=>(A<=>C)',[A,B,C], ([A,B,C])=>{
	makeTheoreme('pre','B<=>C','A<=>C',[A,B,C],DB.C22_2)
})

DB.C23_1 = makeRule('C23-1','A<=>B -> !A<=>!B',([A,B])=>eql(not(A),not(B)), ([A,B])=>{
	DB.prove(eql(A,B),imp(A,B))
	DB.prove(eql(A,B),imp(B,A))
	DB.prove(imp(A,B),imp(not(B),not(A)))
	DB.prove(imp(B,A),imp(not(A),not(B)))
	DB.C20([imp(not(A),not(B)),imp(not(B),not(A))])
})
var C23_1 = makeTheoreme('prem','A<=>B','!A<=>!B',[A,B],DB.C23_1)
DB.C23_2 = makeRule('C23-2','A<=>B -> (A=>C)<=>(B=>C)',([A,B,C])=>eql(imp(A,C),imp(B,C)), ([A,B,C])=>{
	DB.prove(eql(A,B),imp(A,B))
	DB.prove(eql(A,B),imp(B,A))
	DB.C13([A,B,C])
	DB.C13([B,A,C])
	DB.C20([imp(imp(A,C),imp(B,C)),imp(imp(B,C),imp(A,C))])
})
var C23_2 = makeTheoreme('prem','A<=>B','(A=>C)<=>(B=>C)',[A,B,C],DB.C23_2)
DB.C23_3 = makeRule('C23-3','A<=>B -> (C=>A)<=>(C=>B)',([A,B,C])=>eql(imp(C,A),imp(C,B)), ([A,B,C])=>{
	DB.prove(eql(A,B),imp(A,B))
	DB.prove(eql(A,B),imp(B,A))
	makeTheoreme('first',imp(C,A),imp(C,B), [C,A,B],DB.C6)
	makeTheoreme('first',imp(C,B),imp(C,A), [C,B,A],DB.C6)
	DB.C20([imp(imp(C,A),imp(C,B)),imp(imp(C,B),imp(C,A))])
})
var C23_3 = makeTheoreme('prem','A<=>B','(C=>A)<=>(C=>B)',[A,B,C],DB.C23_3)
var S4_inv = makeTheoreme('prem','A=>B','A||C=>B||C',[A,B,C],([A,B,C])=>{
	DB.prove(imp(A,B),imp(or(C,A),or(C,B)))
	makeTheoreme('prem','A||C','B||C',[A,B,C], ([A,B,C])=>{
		DB.prove('A||C','C||A')
		DB.prove('C||A','C||B')
		DB.prove('C||B','B||C')
	})
})
DB.C23_5 = makeRule('C23-5','A<=>B -> A||C<=>B||C',([A,B,C])=>eql(or(A,C),or(B,C)), ([A,B,C])=>{
	DB.prove(eql(A,B),imp(A,B))
	DB.prove(eql(A,B),imp(B,A))
	DB.prove(imp(A,B),imp(or(A,C),or(B,C)))
	DB.prove(imp(B,A),imp(or(B,C),or(A,C)))
	DB.C20([imp(or(A,C),or(B,C)),imp(or(B,C),or(A,C))])
})
var C23_5 = makeTheoreme('prem','A<=>B','A||C<=>B||C',[A,B,C],DB.C23_5)
DB.C23_4 = makeRule('C23-4','A<=>B -> A&&C<=>B&&C',([A,B,C])=>eql(and(A,C),and(B,C)), ([A,B,C])=>{
	DB.C23_1([A,B])
	DB.C23_5([not(A),not(B),not(C)])
	DB.C23_1([or(not(A),not(C)),or(not(B),not(C))])
})
var C23_4 = makeTheoreme('prem','A<=>B','A&&C<=>B&&C',[A,B,C],DB.C23_4)

var C24_1 = DB.C20(['!!A=>A','A=>!!A']);
var C24_2 = DB.C20(['(A=>B)=>(!B=>!A)','(!B=>!A)=>(A=>B)']);
makeTheoreme('prem',A,'A&&A',[A,A],DB.C20)
var C24_3 = DB.C20(['A&&A=>A','A=>A&&A'])

/*todo:
доделать fast exist
	вывод на печать и убрать повторную проверку.
доказать все логические утверждения и прописать подсказки
переходить к кванторным теориям

добавить 2 режима генерации tgf-файлов
*/
</script>
</body>
</html>